---
title: "Grid Approximation"
author: "Adeeba Tak"
data: Sys.Date()
output: pdf_document
header-includes:
  - \usepackage{fvextra}
  - \fvset{breaklines=true}
---

For the globe tossing example, 9 points, 6 wins:
W, L, W, W, W, L, W, L, W

1. Define grid (grid of parameter values)
```{r}
p_grid <- seq(from = 0, to = 1, length.out = 20)
```

2. Define prior
```{r}
prior <- rep(1, 10)

# alternatives: Informative priorsx
# step-function prior: zero below 0.5, constant above
prior <- ifelse(p_grid < 0.5, 0, 1)
# the true probability is most likely around 0.5, and I become drastically less confident as you move toward 0 or 1
prior <- exp(-5*abs(p_grid - 0.5))
```

3. Compute likelihood at each value in the grid
```{r}
likelihood <- dbinom(6, size = 9, prob = p_grid)
```

4. Compute product of likelihood and prior
```{r}
unstd.posterior <- likelihood*prior
```

5. Standardize the posterior (sums to 1)
```{r}
posterior <- unstd.posterior/sum(unstd.posterior)

# display the posterior
library(ggplot2)
ggplot(NULL, aes(x = p_grid, y = posterior)) +
  geom_point()+
  labs(x = "Probability of Water", y = "Posterior Probabiity", subtitle = "20 points") + theme_bw()
```

6. Draw (10,000) samples from the posterior.
```{r}
samples <- sample(p_grid, prob = posterior, size = 1e4, replace = TRUE)
plot(samples)
library(rethinking)
dens(samples)
```

7. Sampling to summarize the posterior distribution

i. Intervals of defined boundaries
```{r}
# posterior probability that the proportion of water is less than 0.5
sum(samples < 0.5)/length(samples)

# posterior probability that the proportion of water is between 0.5 & 0.75
sum(samples > 0.5 & samples < 0.75)/length(samples)

```

ii. Intervals of defined mass
```{r}
# 50% PI, percentile interval
PI(samples, prob = 0.5)
# same as:
quantile(samples, prob = c(0.25, 0.75))

# 50% HPDI, highest posterior density interval (especially useful when the data is skewed and either tail has more "weight")
HPDI(samples, prob = 0.5)
```

iii. Point estimates
```{r}
# absolute loss
loss <- sapply( p_grid , function(d) sum( posterior*abs( d - p_grid ) ) )
#corresponding POINT ESTIMATE
p_grid[which.min(loss)]
```

